# **<center> PROJECT-1. Анализ резюме из HeadHunter </center>**

## Оглавление

[About](#about)

[1. Постановка задачи](#1. Постановка задачи)

[2. Исследование структуры данных](#2-исследование-структуры-данных)

[3. Преобразование данных](#3-преобразование-данных)

[4. Исследование зависимостей в данных](#4-исследование-зависимостей-в-данных)

[5. Очистка данных](#5-очистка-данных)

[Итоги и финальное задание](#итоги-и-финальное-задание)

## <center id = about> **1. Постановка задачи </center>**

✍ Настало время попробовать свои силы в реальном **Data Science-проекте**. Вам предстоит решить часть настоящей бизнес-задачи и примерить роль аналитика в компании **HeadHunter**. Проект станет новым этапом сбора вашего портфолио на **GitHub**, которым вы сможете похвастаться перед работодателем!

![](https://lms-cdn.skillfactory.ru/assets/courseware/v1/7411a8e45affb7f8c37df2bb2ff1a8e4/asset-v1:SkillFactory+DSPR-2.0+14JULY2021+type@asset+block/dst-3.0_16_1_0.png)

### **<center> <span style="color:green"> ОПИСАНИЕ ЗАДАЧИ#about </span> </center>**

В вашем распоряжении будет база резюме, выгруженная с сайта поиска вакансий hh.ru.

Проблематика: часть соискателей не указывает желаемую заработную плату, когда составляет своё резюме.

**<details>**
    <summary> <span style="color:green"> Чем это плохо? </span> </summary>
    Это является помехой для рекомендательной системы **HeadHunter**, которая подбирает соискателям список наиболее подходящих вакансий, а работодателям — список наиболее подходящих специалистов.
    </details>

⭐ Компания **HeadHunter** хочет построить модель, которая бы автоматически определяла примерный уровень заработной платы, подходящей пользователю, исходя из информации, которую он указал о себе. Но, как вы знаете, прежде чем построить модель, данные необходимо преобразовать, исследовать и очистить. **В этом и состоит наша с вами задача!**

**ОРГАНИЗАЦИОННАЯ ИНФОРМАЦИЯ**

Наш проект будет состоять из четырёх частей:

1. базовый анализ структуры данных

2. преобразование данных

3. разведывательный анализ

4. очистка данных

Каждая часть будет состоять из блока практических заданий, которые вам необходимо выполнить в своих **jupyter**-ноутбуках, и контрольных вопросов на платформе, отвечая на которые вы сможете проверить верность своего решения. Задания выполняются последовательно.

Помимо проверки заданий на платформе, вам предстоит отправить свой код ментору для **code**-ревью. Вам будет предоставлен ноутбук-шаблон и требования, согласно которым вы должны оформить своё решение.

**ЧТО НЕОБХОДИМО СДЕЛАТЬ ДЛЯ УСПЕШНОГО ВЫПОЛНЕНИЯ ПРОЕКТА?**

- Внимательно изучить детали задачи.
- Скачать уже знакомый **датасет** и **ноутбук-шаблон**.
- Обязательно ознакомиться с дополнительным теоретическим материалом, который даётся перед заданием.
- Воспользоваться нашими советами и подсказками при выполнении проекта.
- Ответить на все контрольные вопросы: за них вы можете максимально **набрать 30 баллов на платформе**.
- Загрузить ноутбук со своим решением на **GitHub**, оформив его в соответствии с требованиями.
- Сдать проект на проверку и **получить 10 баллов** (из них 8 баллов — за основное задание и 2 балла — за дополнительное) за выводы по разведывательному анализу.
- Получить обратную связь от команды курса.

**Для успешного выполнения проекта вам необходимо набрать 21 балл из 40 возможных**.

**<center> <span style="color:green"> Требования к оформлению ноутбука-решения </span> </center>**

- Решение оформляется только в **Jupyter Notebook**.

- Решение оформляется в соответствии с ноутбуком-шаблоном.

- Каждое задание выполняется в отдельной ячейке, выделенной под задание (в шаблоне они помечены как **ваш код здесь**). Не следует создавать множество ячеек для решения задачи — это создаёт неудобства при проверке.

- Код для каждого задания оформляется в одной-двух **jupyter**-ячейках (не стоит создавать множество ячеек для решения задачи, это усложняет проверку).

- Решение должно использовать только пройденный материал: переменные, основные структуры данных (списки, словари, множества), циклы, функции, библиотеки **numpy**, **pandas**, **matplotlib**, **seaborn**, **plotly**. Если вы думаете, что для решения необходимо воспользоваться сторонними библиотеками или инструментами (например **Excel**), другими языками программирования или неизученными конструкциями, вы ошибаетесь :) Все задания решаются с помощью уже знакомых методов.

- Код должен быть читаемым и понятным: имена переменных и функций отражают их сущность, важно избегать многострочных конструкций и условий.

- Пользуйтесь **[руководством PEP 8](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/jump_to_id/958c1e42860d475999e9f9381dfe8b5a)**.

- Графики оформляются в соответствии с теми правилами, которые мы приводили **[в модуле по визуализации данных](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/jump_to_id/1fa00a018157484a9bae5d4557ef3e7c)**.

- **Обязательное требование**: графики должны содержать название, отражающее их суть, и подписи осей.

- Выводы к графикам оформляются в формате **Markdown** под самим графиком в отдельной ячейке (в шаблоне они помечены как **ваши выводы здесь**). Выводы должны быть представлены в виде небольших связанных предложений на русском языке.

**[к оглавлению](#оглавление)**

## **<center> 2. Исследование структуры данных </center>**

✍ Начинаем мы, конечно же, со знакомства с данными и исследования их структуры. Нам важно понять, как устроены признаки в данных и какие типы они имеют, чтобы произвести дальнейшие преобразования.

**Задание 2.1**

Прочитайте данные с помощью библиотеки **Pandas**. Перед чтением обратите внимание на разделитель внутри файла.  
**Чему равна размерность таблицы? Введите её в виде кортежа (число строк, число столбцов)**.

Возможный вариант решения:  

```python

data = pd.read_csv("data/hh_database.csv", sep=";")

print(data.shape)

```

Вариант решения с указанием пути нахождения файла dst-3.0_16_1_hh_database.csv:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

print(data.shape)

```

**Ответ**:  

- [x] (44744, 12)

**Задание 2.2**

Выведите несколько первых (последних) строк таблицы, чтобы убедиться в том, что ваши данные не повреждены. Ознакомьтесь с признаками и их структурой.  
**В каком формате представлен порядок слов в признаке «Пол, возраст»?**

Возможное решение:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

display(data.head(2))

```

**Ответ**:  

- [x] <Пол , возраст , дата рождения>

**Задание 2.3**

Выведите основную информацию о числе непустых значений в столбцах и их типах в таблице.  
**Какой тип данных имеют все столбцы? Введите его в поле для ответа.**

Возможный вариант решения:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

display(data.info())

```

**Ответ**:  

- [x] object

**Задание 2.4**

Обратите внимание на информацию о числе непустых значений.  
**Выберите все признаки, в которых есть пропуски в данных**:

Возможный вариант решения:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

display(data.info())

```

**Ответ**:

- [x] Последняя/нынешняя должность
- [x] Опыт работы
- [x] Последнее/нынешнее место работы

**Задание 2.5**

Выведите основную статистическую информацию о столбцах.  

- **Сколько уникальных значений содержится в столбце «Опыт работы»?**  
- **Какая из искомых должностей самая распространённая? Введите название.**

Возможное решение:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

display(data.describe())

```

**Ответ**:  

- [x] 44413
- [x] системный администратор

✍ Итак, ещё раз внимательно присмотритесь к столбцам таблицы и информации, которую они содержат: это поможет вам успешно выполнить проект. Ну а мы начинаем настоящую работу с данными!

**[к оглавлению](#оглавление)**

## **<center> 3. Преобразование данных </center>**

✍ Теперь, когда мы познакомились с информацией в таблице, настало время самого сложного этапа — **предобработки данных**.

Как вы могли уже заметить, наши данные очень «сырые»: признаки представлены в неудобном для анализа и очистки формате.

Например, столбец «Пол/возраст» содержит информацию и о поле, и о возрасте, и о дате рождения. Желаемая заработная плата представлена в виде текста с указанием валюты, в которой она исчисляется, и так далее…

Всё это не позволяет нам визуально оценить зависимости в данных: построить гистограмму распределения зарплаты и возраста, столбчатую диаграмму зарплаты по уровню образования и многое другое. Более того, мы не можем в таком виде заполнить пропущенные значения числовыми константами или найти выбросы. Иными словами, нам необходимо **преобразовать данные**, что позволит грамотно работать с ними.

⚡ Важно! Старайтесь выполнять обработку с помощью функций-преобразований (**lambda-функций**), которые принимают аргументом элемент столбца и возвращают его преобразованную версию. Данные функции применяйте к признакам с помощью метода **apply()**.

Начнём с простого — с признака «Образование и ВУЗ». Его текущий формат — это: <**<span style="color:red">Уровень образования</span> <span style="color:green">год выпуска</span> ВУЗ <span style="color:blue">специальность</span>**...>. Например:

- Высшее образование 2016 Московский авиационный институт (Национальный исследовательский университет)
- Неоконченное высшее образование 2000 Балтийская государственная академия рыбопромыслового флота  

Нас будет интересовать **только уровень образования**. Причём, для простоты мы будем считать, что соискатель указывает свой максимальный уровень образования в первых трёх словах столбца «Образование и ВУЗ».

Создайте с помощью функции-преобразования новый признак «Образование», который должен иметь четыре категории: «высшее», «неоконченное высшее», «среднее специальное» и «среднее».

Выполните преобразование, ответьте на контрольные вопросы и удалите признак «Образование и ВУЗ».

**<details>**
    <summary> <span style="color:green">Совет первый</span> </summary>
    Обратите внимание на структуру текста в столбце «Образование и ВУЗ». Гарантируется, что текущий уровень образования соискателя всегда отражён в первых трёх словах и начинается с заглавной буквы. Воспользуйтесь этим.
</details>

**<details>**
    <summary> <span style="color:green">Совет второй</span> </summary>
     Проверяйте полученные категории, например с помощью метода **`unique()`**
</details>

**Задание 3.1**

Сколько соискателей имеет средний уровень образования (школьное образование)?  

**? Подсказка (1 из 2)**: Напишите функцию, которая ищет среди первых трёх слов подстроки «Высшее», «Неоконченное высшее», «Среднее специальное» и «Среднее», найдите эти подстроки и на их основе создайте категории в новом признаке.

**? Подсказка (2 из 2)**: Для того чтобы выделить первые три слова, можно воспользоваться методом **`split()`** и указать разделитель пробела, выделить первые три элемента, после чего объединить результат в одну строку с помощью метода **`join()`** и производить поиск в полученной строке.

Возможное решение:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

def get_education(arg):
    arg = ' '.join(arg.split(' ')[:3])
    if 'Высшее' in arg:
        return 'высшее'
    elif 'Неоконченное высшее' in arg:
        return 'неоконченное высшее'
    elif 'Среднее специальное' in arg:
        return 'среднее специальное'
    elif 'Среднее образование' in arg:
        return 'среднее'
data['Образование'] = data['Образование и ВУЗ'].apply(get_education)
data = data.drop('Образование и ВУЗ', axis=1)
print(data['Образование'].value_counts()['среднее'])

```

**Ответ**:  

- [x] 559

**Задание 3.2**

- Сколько процентов женских резюме представлено в наших данных? Ответ округлите до сотых.  
- Чему равен средний возраст соискателей? Ответ округлите до десятых.

**? Подсказка (1 из 2)**: Для того чтобы определить пол, достаточно проверить строку на наличие слов «Мужчина» или «Женщина».

**? Подсказка (2 из 2)**: Для того чтобы найти в строке возраст, можно ввести список ключевых слов ["год", "года", "лет"], пройтись по словам в строке и определить индекс одного из ключевых слов. Возрастом будет слово, чей индекс на 1 меньше ключевого. Не забудьте преобразовать строку с возрастом в целое число, например с помощью функции **`int()`**.

Возможный вариант решения:

```python

import pandas as pd

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

def get_sex(arg):
    if 'Мужчина' in arg:
        return 'М'
    else:
        return 'Ж'
    
def get_age(arg):
    arg_splitted = arg.split(' ')
    year_words=['год', 'года', 'лет']
    for index, item in enumerate (arg_splitted):
        if item in year_words:
            return int(arg_splitted[index-1])

data['Пол'] = data['Пол, возраст'].apply(get_sex)
data['Возраст'] = data['Пол, возраст'].apply(get_age)
data = data.drop('Пол, возраст', axis=1)

print(round(data['Пол'].value_counts(normalize=True)['Ж'] * 100, 2))
print(round(data['Возраст'].mean(), 2))

```

**Ответ**:  

- [x] 19.07 или 19,07
- [x] 32.2 или 32,2

Следующим этапом преобразуем признак «Опыт работы». Его текущий формат: <Опыт работы: **<span style="color:red">n</span>** лет **<span style="color:blue">m</span>** месяцев, периоды работы в различных компаниях…>.

Из столбца нам необходимо выделить общий опыт работы соискателя в месяцах, новый признак назовём «Опыт работы (месяц)».

Для начала обсудим условия решения задачи:

1. Во-первых, в данном признаке есть пропуски. Условимся, что, если мы встречаем пропуск, оставляем его как есть (функция-преобразование возвращает **NaN**).
2. Во-вторых, в данном признаке есть скрытые пропуски. Для некоторых соискателей в столбце стоит значение Не указано. Их тоже обозначим как **NaN** (функция-преобразование возвращает **NaN**)
3. В-третьих, нас не интересует информация, которая описывается после указания опыта работы (периоды работы в различных компаниях).

4. В-четвёртых, у нас есть проблема: опыт работы может быть представлен только в годах или только в месяцах. Например, можно встретить следующие варианты:
   - Опыт работы 3 года 2 месяца
  
   - Опыт работы 4 года

   - Опыт работы 11 месяцев

Учитывайте эту особенность в вашем коде.

**В результате преобразования у вас должен получиться столбец, содержащий информацию о том, сколько месяцев проработал соискатель**.

Выполните преобразование и удалите столбец «Опыт работы» из таблицы.

**Задание 3.3**

Чему равен медианный опыт работы (в месяцах) в нашей таблице?  

**? Подсказка (1 из 2)**: Символ **nan** можно взять из библиотеки **numpy**: **np.nan**.

**? Подсказка (2 из 2)**: Для того чтобы найти число лет и месяцев, можно ввести списки возможных ключевых слов <'год', 'года', 'лет'> и <'месяц', 'месяца', 'месяцев'>. А после пробежаться по словам в строке в цикле и определить индексы ключевых слов; интересующие нас значения числа лет и месяцев находятся под индексом на 1 меньше ключевого.

Возможное решение:

```python

import numpy as np

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

def get_experience(arg):
    if arg is np.nan or arg == 'Не указано':
        return None
    year_words=['год', 'года', 'лет']
    month_words=['месяц', 'месяца', 'месяцев']
    arg_splitted = arg.split(' ')[:7]
    years = 0
    months = 0
    for index, item in enumerate (arg_splitted):
        if item in year_words:
            years = int(arg_splitted[index-1])
        if item in month_words:
            months = int(arg_splitted[index-1])
    return int(years*12 + months)
data['Опыт работы (месяц)'] = data['Опыт работы'].apply(get_experience)
#data = data.drop('Опыт работы', axis=1)
print(round(data['Опыт работы (месяц)'].median()))

```

**Ответ**:  

- [x] 100

Хорошо идём! :) Следующий на очереди — признак «Город, переезд, командировки». Информация в нём представлена в следующем виде: <**<span style="color:red">Город</span>**, **<span style="color:pink">(метро)</span>**, **<span style="color:green">готовность к переезду</span>** (**города для переезда**), **<span style="color:blue">готовность к командировкам></span>**.

В скобках указаны необязательные параметры строки. Например, можно встретить следующие варианты:

- Москва , не готов к переезду , готов к командировкам
- Москва , м. Беломорская , не готов к переезду, не готов к командировкам
- Воронеж , готов к переезду (Сочи, Москва, Санкт-Петербург) , готов к командировкам

**Создадим отдельные признаки «Город», «Готовность к переезду», «Готовность к командировкам». При этом важно учесть**:

⛏ Признак «Город» может содержать только четыре категории: «Москва», «Санкт-Петербург» и «город-миллионник» (их список ниже), остальные обозначьте как «другие».

**<details>**

<summary> <span style="color:green">Список городов-миллионников</span> </summary>

```python
million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород', 'Казань', 'Челябинск', 'Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж', 'Волгоград' ]
```

</details>

Информация о метро, рядом с которым проживает соискатель, нас не интересует.

⛏ Признак «Готовность к переезду» должен иметь два возможных варианта: **True** или **False**. Обратите внимание, что возможны несколько вариантов описания готовности к переезду в признаке «Город, переезд, командировки». Например:

- … , готов к переезду , …
- … , не готова к переезду , …
- … , готова к переезду (Москва, Санкт-Петербург, Ростов-на-Дону)
- … , хочу переехать (США) , …
Нас интересует только сам факт возможности/желания переезда.

Нас интересует только сам факт возможности/желания переезда.

⛏ Признак «Готовность к командировкам» должен иметь два возможных варианта: **True** или **False**. Обратите внимание, что возможны несколько вариантов описания готовности к командировкам в признаке «Город, переезд, командировки». Например:

- … , готов к командировкам , …
- … , готова к редким командировкам , …
- … , не готов к командировкам , …  

Нас интересует только сам факт готовности к командировке.

**Ещё один важный момент**: при выгрузке данных у некоторых соискателей «потерялась» информация о готовности к командировкам. Давайте по умолчанию будем считать, что такие соискатели не готовы к командировкам.

**Выполните преобразования и удалите столбец «Город, переезд, командировки» из таблицы**.

**<details>**
<summary> <span style="color:green">Совет</span> </summary>
Обратите внимание на то, что структура текста может меняться в зависимости от указания ближайшего метро. Учтите это, если будете использовать порядок слов в своей программе.
</details>

**Задание 3.4**
  
- Сколько процентов соискателей живут в Санкт-Петербурге? Ответ округлите до целого.  
- Сколько процентов соискателей готовы одновременно и к переездам, и к командировкам? Ответ округлите до целого.

**? Подсказка (1 из 2)**: Для того чтобы разделить признак на составляющие, можно воспользоваться методом строки **`split()`** с разделителем ' **,** ', который вернёт список, нулевой элемент в котором — город.

**? Подсказка (2 из 2)**: Для того чтобы определить готовность к переезду, достаточно проверить строку на наличие подстрок **не готов к переезду** или **не готова к переезду** Аналогичная логика может использоваться для определения готовности к командировкам.

Возможное решение:

```python

import numpy as np

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

def get_city(arg):
    million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород',
                      'Казань', 'Челябинск', 'Омск', 'Самара', 'Ростов-на-Дону', 
                      'Уфа', 'Красноярск', 'Пермь', 'Воронеж', 'Волгоград'
                     ]
    city = arg.split(' , ')[0]
    if (city == 'Москва') or (city == 'Санкт-Петербург'):
        return city
    elif city in million_cities:
        return 'город миллионник'
    else:
        return 'другие'
    
def get_ready_to_move(arg):
    if ('не готов к переезду' in arg) or ('не готова к переезду' in arg):
        return False
    elif 'хочу' in arg:
        return True
    else:
        return True
    
def get_ready_for_bisiness_trips(arg):
    if ('командировка' in arg):
        if ('не готов к командировкам' in arg) or('не готова к командировкам' in arg):
            return False
        else: 
            
            return True
    else:
        return False
    
data['Город'] = data['Город, переезд, командировки'].apply(get_city)
data['Готовность к переезду'] = data['Город, переезд, командировки'].apply(get_ready_to_move)
data['Готовность к командировкам'] = data['Город, переезд, командировки'].apply(get_ready_for_bisiness_trips)
data = data.drop('Город, переезд, командировки', axis=1)
print(round(data['Город'].value_counts(normalize=True)['Санкт-Петербург'] * 100)) 
print(round(data[
    data['Готовность к переезду'] & data['Готовность к командировкам']
].shape[0] / data.shape[0] *100))

```

**Ответ**:  

- [x] 11
- [x] 32

Рассмотрим поближе признаки «Занятость» и «График».

Сейчас признаки представляют собой набор категорий желаемой занятости (полная занятость, частичная занятость, проектная работа, волонтёрство, стажировка) и желаемого графика работы (полный день, сменный график, гибкий график, удалённая работа, вахтовый метод).

На сайте **hh.ru** соискатель может указывать различные комбинации данных категорий, например:

- полная занятость, частичная занятость;
- частичная занятость, проектная работа, волонтёрство;
- полный день, удалённая работа;
- вахтовый метод, гибкий график, удалённая работа, полная занятость.  
  
Такой вариант признаков имеет множество различных комбинаций, а значит, множество уникальных значений, что мешает анализу. Нужно это исправить!

**Давайте создадим признаки-«мигалки» для каждой категории: если категория присутствует в списке желаемых соискателем, то в столбце на месте строки рассматриваемого соискателя ставится True, иначе — False**.

Такой метод преобразования категориальных признаков называется <span style="color:green">**One Hot Encoding**</span>, его схема представлена на рисунке ниже:

![](https://lms-cdn.skillfactory.ru/assets/courseware/v1/5461aeb8c39a8cb9731eb5f52b66f5a3/asset-v1:SkillFactory+DSPR-2.0+14JULY2021+type@asset+block/dst-3.0_16_3_1.png)

**Выполните данное преобразование для признаков «Занятость» и «График», ответьте на контрольные вопросы, после чего удалите их из таблицы**.

**Задание 3.5**
  
- Сколько людей ищут проектную работу и волонтёрство (в обоих столбцах стоит **True**)?  
- Сколько людей хотят работать вахтовым методом и с гибким графиком (в обоих столбцах стоит **True**)**?

**? Подсказка (1 из 1)**: Можно создать списки из категорий занятости и графика. После чего пройтись по данным спискам в цикле и создавать новые признаки с названиями категорий, значения которых — результат проверки принадлежности категории к перечню категорий в ячейке таблицы. Например, **`data[col].apply(lambda x: employment in x)`**, где **employment** — одна из категорий занятости.

Возможное решение:

```python

import numpy as np

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')


employments = ['полная занятость', 'частичная занятость',
              'проектная работа', 'волонтерство', 'стажировка']
charts = ['полный день', 'сменный график', 
         'гибкий график', 'удаленная работа',
         'вахтовый метод']
for employment, chart in zip(employments, charts):
    data[employment] = data['Занятость'].apply(lambda x: employment in x)
    data[chart] = data['График'].apply(lambda x: chart in x)
data = data.drop('Занятость', axis=1)
data = data.drop('График', axis=1)
print(data[data['проектная работа'] & data['волонтерство']].shape[0])
print(data[data['вахтовый метод'] & data['гибкий график']].shape[0])

```

**Ответ**:  

- [x] 436
- [x] 2311

Наконец, мы добрались до самого главного — признака заработной платы «ЗП».

В чём наша проблема? — В том, что помимо желаемой заработной платы соискатель указывает валюту, в которой он хотел бы её получать, например:

- 30 000 руб.;
- 50 000 грн.;
- 550 USD.
  
Нам бы хотелось видеть заработную плату в единой валюте, например в рублях. Возникает вопрос: а где взять курс валют по отношению к рублю?

На самом деле язык Python имеет в арсенале огромное количество возможностей получения данной информации: от обращения к API Центробанка, до использования специальных библиотек, например **[pycbrf](https://github.com/idlesign/pycbrf)**. Однако в рамках нашего проекта эти темы мы рассматривать не будем.

Поэтому просто обратимся к профильным интернет-ресурсам для получения данных о курсе в виде текстовых файлов. Например, **[MFD.RU](https://mfd.ru/export/#Alias=false&Period=1&timeframeValue=1&timeframeDatePart=day&StartDate=04.10.2021&EndDate=04.10.2021&SaveFormat=0&SaveMode=0&FieldSeparator=%253b&DecimalSeparator=.&DateFormat=yyyyMMdd&TimeFormat=HHmmss&AddHeader=true&RecordFormat=0&Fill=false)**: данный ресурс позволяет удобно экспортировать данные о курсах различных валют и акций за указанные периоды в виде csv. Мы уже сделали выгрузку курсов валют, которые встречаются в наших данных за период с 29.12.2017 по 05.12.2019: скачать её вы можете **[здесь](https://lms-cdn.skillfactory.ru/assets/courseware/v1/15abf80f45a2f3e93c3274101b451c67/asset-v1:SkillFactory+DSPR-2.0+14JULY2021+type@asset+block/ExchangeRates.zip)**.

**Создайте новый DataFrame из скачанного файла**. В полученной таблице нас будут интересовать столбцы:

- **currency** — наименование валюты в **ISO**-кодировке;
- **date** — дата;
- **proportion** — пропорция;
- **close** — цена закрытия (последний зафиксированный курс валюты на указанный день).

Перед вами таблица соответствия наименований иностранных валют в наших данных и их общепринятых сокращений, которые представлены в файле с курсами валют.

> **Пропорция** — это число, отражающее, скольким единицам валюты соответствует курс в таблице с курсами. Например для казахстанского тенге курс на 20.08.2019 составляет 17.197 руб. за 100 тенге, тогда итоговый курс равен: 17.197 / 100 = 0.17197 руб. за 1 тенге.

Воспользуйтесь этой информацией в ваших преобразованиях.

![alt text](image.png)

Осталось только понять, откуда брать дату, по которой определяется курс. А вот же она — в признаке «Обновление резюме» содержится дата и время, когда соискатель выложил текущий вариант своего резюме. Нас интересует только дата, по ней мы и будем сопоставлять курсы валют.

Теперь у нас есть вся необходимая информация для того, чтобы создать признак «ЗП (руб)» — заработная плата в рублях.

Итак, давайте обсудим возможный алгоритм преобразования.

**<details>**
<summary> <span style="color:green">Подсказки</span> </summary>

1. Обновить признак "Обновление резюме" из таблицы с резюме, переведя его в формат **datetime** и выделив из него дату. То есть в дате обновления резюме мы намеренно отсекаем время, оставляя только дату выставления резюме. В тот же формат привести признак **date** из таблицы с валютами. Обратите внимание на формат даты в исходных столбцах (день-месяц-год), учтите этот факт при преобразовании.

2. Выделить из столбца «ЗП» сумму желаемой заработной платы и наименование валюты, в которой она исчисляется. Наименование валюты перевести в стандарт **ISO** согласно таблице выше.

3. Присоединить к таблице с резюме таблицу с курсами по столбцам с датой и названием валюты (подумайте, какой тип объединения надо выбрать, чтобы в таблице с резюме сохранились данные о заработной плате, изначально представленной в рублях). Значение **close** для рубля заполнить единицей 1 (курс рубля самого к себе).

4. Умножить сумму желаемой заработной платы на присоединённый курс валюты (**close**) и разделить на пропорцию. Обратите внимание на пропуски после объединения в этих столбцах. Результат занести в новый столбец «ЗП (руб)».

</details>

Удалите исходный столбец заработной платы «ЗП» и все промежуточные столбцы, если вы их создавали.

**Задание 3.6**
  
**Для выполнения этого задания у вас будет 5 попыток. После того как вы дадите правильный ответ ИЛИ истратите все попытки, вы можете нажать на кнопку «Показать ответ»: в конце решения вы увидите ссылку на эталонный ответ**.

Чему равна желаемая медианная заработная плата соискателей в нашей таблице (в рублях)?

Ответ приведите в тысячах рублей и округлите до целого. Например, если у вас получилась медианная з/п 42 127, в качестве ответа укажите 42.

**? Подсказка (1 из 4)**: Для того чтобы отделить размер заработной платы от валюты, можно воспользоваться методом **`split()`** с разделителем пробела.

**? Подсказка (2 из 4)**: Таблицу соответствия можно оформить в виде словаря, ключи которого — варианты написания валют в данных, а значения — коды **ISO**.

**? Подсказка (3 из 4)**: Для объединения необходимо воспользоваться методом **`left`** (если таблица с резюме является левой).

**? Подсказка (4 из 4)**: После объединения значения столбцов **close** и **proportion** для резюме, где желаемая заработная плата указана в рублях будут пропусками. Их нужно заполнить 1 с помощью метода **`fillna()`** .

Возможное решение:

```python

import numpy as np

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

def get_salary_num(arg):
    salary = float(arg.split(' ')[0])
    return salary

def get_salary_currency(arg):
    currency_dict = {
        'USD': 'USD', 'KZT': 'KZT',
        'грн': 'UAH', 'белруб': 'BYN',
        'EUR': 'EUR', 'KGS': 'KGS',
        'сум': 'UZS', 'AZN': 'AZN'
    }
    curr = arg.split(' ')[1].replace('.', '')
    if curr == 'руб':
        return 'RUB'
    else:
        return currency_dict[curr]
    
rates = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\ExchangeRates.csv')
rates['date'] = pd.to_datetime(rates['date'], dayfirst=True).dt.date
data['Обновление резюме'] = pd.to_datetime(data['Обновление резюме'], dayfirst=True).dt.date
data['ЗП (tmp)'] = data['ЗП'].apply(get_salary_num)
data['Курс (tmp)'] = data['ЗП'].apply(get_salary_currency)
merged = data.merge(
    rates, 
    left_on=['Курс (tmp)', 'Обновление резюме'],
    right_on=['currency', 'date',], 
    how='left'
)
merged['close'] = merged['close'].fillna(1)
merged['proportion'] = merged['proportion'].fillna(1)
data['ЗП (руб)'] = merged['close'] * merged['ЗП (tmp)'] / merged['proportion']
data = data.drop(['ЗП', 'ЗП (tmp)', 'Курс (tmp)'], axis=1)
print(round(data['ЗП (руб)'].median()/1000))

```

**Эталонный ответ вы можете посмотреть [здесь](https://drive.google.com/file/d/1j8hEX9ugaLYU_EBqjHdR9b8nMTsB0JBB/view?usp=sharing)**.

**Ответ**:  

- [x] 59

**<details>**
<summary> <span style="color:green">Давайте сверимся с вами?</span> </summary>

![alt text](image-2.png)

</details>

✍ Поздравляем! Вы справились с этапом преобразований данных! Обратите внимание, как много различных манипуляций мы совершили с данными для того, чтобы привести их в подходящий для анализа вид. Это стандартная ситуация, когда мы работаем с неподготовленными, сырыми данными.

На самом деле преобразования могут быть намного сложнее, например они могут использовать специальные методы для обработки текста, такие как сложные составные регулярные выражения или поиск наиболее важных слов в тексте. Иногда может потребоваться привлечение специальных API или использование SQL-запросов к базе, о которых мы поговорим в следующем разделе нашего курса. Подобные задания очень часто попадаются в практической части собеседований, поэтому данный раздел можно считать вашей первой настоящей тренировкой!

**[к оглавлению](#оглавление)**

## **<center> 4. Исследование зависимостей в данных </center>**

✍ Теперь у нас есть всё необходимое, чтобы провести первичный анализ зависимостей в наших данных о резюме. Такой анализ часто называют **разведывательным анализом (EDA)** и он предназначен для выявления связей между признаками, выявления закономерностей, определения распределений признаков, поиска аномалий и других дефектов данных.

Мы уже начали знакомиться с этой важнейшей темой, когда изучали визуализацию и очистку данных, но подробнее мы поговорим о ней в отдельном разделе нашего курса. А пока давайте применим знания о визуальном анализе на практике!

⚡ **Важно!** Основная часть дальнейшей работы будет производиться с созданными в прошлом юните признаками. Вы не сможете выполнить предстоящие задания, если ещё не прошли предыдущие.

**<details>**
<summary> <span style="color:green">Совет</span> </summary>

Проще всего выполнять следующие задания с помощью интерактивной визуализации в **plotly**, чтобы сразу из графиков отвечать на контрольные вопросы. Но вы можете использовать и библиотеки **pandas**, **matplotlib**, **seaborn**.

</details>

Постройте распределение признака «Возраст». Опишите распределение, отвечая на следующие вопросы:

- Чему равна мода распределения?
- Каковы предельные значения признака, в каком примерном интервале находится возраст **большинства** соискателей?
- Есть ли аномалии для данного признака? Если есть, то какие значения вы бы причислили к таковым?

**<details>**
<summary> <span style="color:green">Совет</span> </summary>

Постройте гистограмму и коробчатую диаграмму рядом.

</details>

**Задание 4.1**
  
Чему равно **модальное значение** возраста соискателей?

**? Подсказка (1 из 1)**: В библиотеке **plotly express** гистограмму можно построить с помощью метода **`histogram`**. Дополнительно можно сразу построить рядом **boxplot**, установив параметр **`marginal='box'`**.

Возможное решение:

```python

import plotly.express as px

data = pd.read_csv('D:\! SkillFactory\!_SF_Учебные материалы\PROJECT_1_Анализ резюме из HeadHunter\data\dst-3.0_16_1_hh_database.csv', sep=';')

import plotly.express as px
fig = px.histogram(
    data_frame=data,
    x='Пол, возраст',
    title='Распределение возраста соискателей',
    histnorm='percent',
    width=500,
    marginal='box',
)
fig.show()

```

**Ответ**:  

- [x] 30

Постройте распределение признака «Опыт работы (месяц)». Опишите распределение, отвечая на следующие вопросы:

- Чему равна мода распределения?
- Каковы предельные значения признака, в каком примерном интервале находится опыт работы **большинства** соискателей?
- Есть ли аномалии для признака? Если есть, то какие значения вы бы причислили к таковым?

**<details>**
<summary> <span style="color:green">Совет</span> </summary>

Постройте гистограмму и коробчатую диаграмму рядом.

</details>

**Задание 4.2**
  
Чему равен максимальный опыт работы (в месяцах)?

**? Подсказка (1 из 1)**: В библиотеке **plotly express** гистограмму можно построить с помощью метода **`histogram`**. Дополнительно можно сразу построить рядом **boxplot**, установив параметр **`marginal='box'`**.

Возможное решение:

```python

fig = px.histogram(
    data_frame=data,
    x='Опыт работы (месяц)',
    title='Распределение опыта работы соискателей',
    histnorm='percent',
    width=500,
    marginal='box',
)
fig.show()

```

**Ответ**:  

- [x] 1188

Постройте распределение признака «ЗП (руб)». Опишите распределение, отвечая на следующие вопросы:

- Чему равна мода распределения?
- Каковы предельные значения признака, в каком примерном интервале находится заработная плата большинства соискателей?
- Есть ли аномалии для признака заработной платы? Если есть, то какие значения вы бы причислили к таковым?

**<details>**
<summary> <span style="color:green">Совет</span> </summary>

Постройте гистограмму и коробчатую диаграмму рядом.

</details>

**Задание 4.3**
  
Определите по графику, сколько соискателей требуют заработную плату выше 1 миллиона рублей.

Возможное решение:

```python

fig = px.histogram(
    data_frame=data,
    x='ЗП (руб)',
    title='Распределение желаемой з/п соискателей',
    histnorm='percent',
    width=500,
    marginal='box'
)
fig.show()

```

**Ответ**:  

- [x] 5

Постройте диаграмму, которая показывает зависимость медианной желаемой заработной платы («ЗП (руб)») от уровня образования («Образование»).

Используйте для диаграммы данные о резюме, где желаемая заработная плата меньше 1 миллиона рублей.

Сделайте выводы по представленной диаграмме:

- Для каких уровней образования наблюдаются наибольшие и наименьшие уровни желаемой заработной платы?
- Как вы считаете, важен ли признак уровня образования при прогнозировании заработной платы?
  
**Задание 4.4**
  
Какая категория образования оплачивается выше всех по медианному показателю?

**? Подсказка (1 из 1)**: Отфильтруйте данные по условию ЗП (руб) < 1 млн. Сгруппируйте данные по уровню образования и вычислите медианную заработную плату. Не забудьте при группировке выставить параметр **`as_index=False`** (**plotly express** работает только с **DataFrame**, а не с **Series**). Для построения столбчатой диаграммы в **plotly** можно использовать метод **`bar()`**.

Возможное решение:

```python

bar_data = data[data['ЗП (руб)']<1e6].groupby('Образование', as_index=False).agg({'ЗП (руб)': 'median'})
fig = px.bar(
    data_frame=bar_data,
    x='Образование',
    y='ЗП (руб)',
    title='Медианная з/п по уровню образования'
)
fig.show()

```

**Ответ**:  

- [x] высшее **или** высшее образование

**Задание 4.5**
  
В каком городе (категории городов) зафиксирован наибольший показатель желаемой заработной платы (~924 тысячи рублей)?

**? Подсказка (1 из 2)**: Для сравнения распределений используйте коробчатую диаграмму.

**? Подсказка (2 из 2)**: В библиотеке plotly за построение коробчатой диаграммы отвечает метод **`box()`**. Для разделения распределений по городам используйте параметр **`color='Город'`**.

Возможное решение:

```python

box_data = data[data['ЗП (руб)']<1e6]
fig = px.box(
    data_frame=box_data,
    x='Город',
    y='ЗП (руб)',
    color='Город',
    title='Распределение з/п по городам'
)
fig.show()

```

**Ответ**:  

- [x] другие **или** другое

Постройте многоуровневую столбчатую диаграмму, которая показывает зависимость медианной заработной платы («ЗП (руб)») от признаков «Готовность к переезду» и «Готовность к командировкам». Проанализируйте график, сравнив уровень заработной платы по категориям.

**Задание 4.6**
  
Чему равна желаемая **медианная** заработная плата соискателей, готовых и к переезду, и к командировкам? Ответ приведите в тысячах, округлив до целого (например, 45).

**? Подсказка (1 из 1)**: Сгруппируйте данные по обоим признакам и рассчитайте медианную заработную плату. Не забудьте при группировке установить параметр **`as_index=False`**. Визуализировать результат можно с помощью функции **`bar()`**.

Возможное решение:

```python

bar_data = data.groupby(
    ['Готовность к командировкам', 'Готовность к переезду'],
    as_index=False
)['ЗП (руб)'].median()
fig = px.bar(
    data_frame=bar_data,
    y='Готовность к переезду',
    x='ЗП (руб)',
    barmode="group",
    color='Готовность к командировкам',
    orientation='h',
    title='Медианная з/п по готовности к командировкам/переезду'
)
fig.show()

```

**Ответ**:  

- [x] 66

Постройте сводную таблицу, иллюстрирующую зависимость медианной желаемой заработной платы от возраста («Возраст») и образования («Образование»).

По полученной сводной таблице постройте тепловую карту.

Проанализируйте тепловую карту, сравнив показатели внутри групп.

**Задание 4.7**
  
Для какой категории образования наблюдается самый быстрый карьерный рост (то есть интенсивность роста заработной платы наибольшая)?

**? Подсказка (1 из 1)**: Сводную таблицу можно построить с помощью метода **`pivot_table()`**, для указания агрегации используйте параметр **`aggfunc='median'`**. Для построения тепловой карты в библиотеке **plotly** можно использовать функцию **`px.imshow()`**.

Возможное решение:

```python

pivot = data.pivot_table(
    index='Образование',
    columns='Возраст',
    values='ЗП (руб)',
    aggfunc='median',
    fill_value=0
)
fig = px.imshow(
    pivot,
    aspect='auto',
    color_continuous_scale='greens',
    title='Медианная з/п по образованию и возрасту'
)
fig.show()

```

**Ответ**:  

- [x] высшее **или** высшее образование

Постройте диаграмму рассеяния, показывающую зависимость опыта работы («Опыт работы (месяц)») от возраста («Возраст»). Опыт работы переведите из месяцев в года, чтобы признаки были в едином масштабе.

Постройте на графике дополнительно прямую, проходящую через точки (0, 0) и (100, 100). Данная прямая соответствует значениям, когда опыт работы равен возрасту человека. Точки, лежащие на этой прямой и выше неё, — аномалии в наших данных (опыт работы больше либо равен возрасту соискателя).

**Задание 4.8**
  
Сколько точек лежат строго **выше** построенной прямой? Так как точки могут сливаться с прямой, то для ответа на этот вопрос проще всего воспользоваться интерактивной визуализацией либо получить таблицу с наблюдениями, лежащими выше прямой с помощью фильтрации.

**? Подсказка (1 из 1)**: Прямую можно построить, указав в параметрах линейного графика **`x=[0, 100], y=[0, 100]`**.

Возможное решение:

```python

import matplotlib.pyplot as plt
import seaborn as sns

fig = plt.figure(figsize=(10, 5))
scatter_data = data.copy()
scatter_data['Опыт работы (год)'] = scatter_data['Опыт работы (месяц)']/12
sns.lineplot(x=[0, 100], y=[0, 100])
ax = sns.scatterplot(
    data=scatter_data, 
    x='Возраст',
    y='Опыт работы (год)',
)
ax.set_title('Зависимость опыта работы от возраста');

```

**Ответ**:  

- [x] 7

✍ Мы провели разведывательный анализ. Догадываетесь, каким будет следующий этап? Всё верно: переходим к очистке! Но прежде давайте обратимся к дополнительным возможностям этого этапа.

**? КАК ПОЛУЧИТЬ ДОПОЛНИТЕЛЬНЫЕ 2 БАЛЛА ЗА ИТОГОВЫЙ ПРОЕКТ?**

Как вы понимаете, этим наше исследование не ограничивается: его можно значительно расширить. Для получения двух дополнительных баллов по разведывательному анализу постройте ещё два любых содержательных графика или диаграммы, которые помогут проиллюстрировать влияние признаков/взаимосвязь между признаками/распределения признаков.

Приведите выводы по ним. Желательно, чтобы в анализе участвовали признаки, которые мы создавали ранее, в разделе **Преобразование данных**.

**[к оглавлению](#оглавление)**

## **<center> 5. Очистка данных </center>**

✍ Когда мы проводили визуальный анализ, мы нашли несколько несостыковок в данных: пропуски, гигантские размеры желаемых заработных плат, резюме людей слишком «преклонного» возраста, опыт работы, превышающий возраст.

Всё это говорит о том, что данные подлежат очистке. Приступим!

**Задание 5.1**
  
Начнём с дубликатов в наших данных. Найдите полные дубликаты в таблице с резюме и удалите их.

**Сколько полных копий удалось найти?**

Возможное решение:

```python

duplicates = data[data.duplicated(subset=data.columns)]
data = data.drop_duplicates()
print(duplicates.shape[0])

```

**Ответ**:  

- [x] 155 **или** 161

⚡ **Важно!** Дальнейшая работа производится с очищенными от дубликатов данными.

**Задание 5.2**
  
Займёмся пропусками. Выведите информацию о числе пропусков в столбцах.

**Сколько пропусков в столбце «Опыт работы (месяц)»?**

Возможное решение:

```python

null_data = data.isnull().sum()
display(null_data[null_data > 0])

```

**Ответ**:  

- [x] 168

Итак, у нас есть пропуски в трёх столбцах: «Опыт работы (месяц)», «Последнее/нынешнее место работы», «Последняя/нынешняя должность». Поступим следующим образом: **удалите строки, где есть пропуск в столбцах с местом работы и должностью**.

Пропуски в столбце с опытом работы заполните медианным значением.

**Задание 5.3**
  
Чему равно результирующее среднее значение в столбце «Опыт работы (месяц)» после заполнения пропусков? Ответ округлите до целых.

Возможное решение:

```python

data = data.dropna(subset=['Последнее/нынешнее место работы', 'Последняя/нынешняя должность'])
data['Опыт работы (месяц)'] = data['Опыт работы (месяц)'].fillna(data['Опыт работы (месяц)'].median())
print(round(data['Опыт работы (месяц)'].mean()))

```

**Ответ**:  

- [x] 114

⚡ **Важно!** Дальнейшая работа производится с очищенными от дубликатов и пропусков данными.

Мы добрались до ликвидации выбросов. Сначала очистим данные вручную.

Удалите резюме, в которых указана заработная плата либо выше 1 миллиона рублей, либо ниже 1 тысячи рублей.

**Задание 5.4**
  
Сколько выбросов вы нашли?

Возможное решение:

```python

outliers = data[(data['ЗП (руб)'] > 1e6) | (data['ЗП (руб)'] < 1e3)]
data = data.drop(outliers.index)
print(outliers.shape[0])

```

**Ответ**:  

- [x] 89

В процессе разведывательного анализа мы обнаружили резюме, в которых опыт работы в годах превышал возраст соискателя. Найдите такие резюме и удалите их из данных.

**Задание 5.5**
  
Сколько выбросов вы нашли?

Возможное решение:

```python

outliers = data[data['Опыт работы (месяц)']/12 >= data['Возраст']]
data = data.drop(outliers.index)
print(outliers.shape[0])

```

**Ответ**:  

- [x] 7

В результате анализа мы обнаружили потенциальные выбросы в признаке **Возраст**. Это оказались резюме людей, чей возраст слишком преклонный для поиска работы.

Попробуйте построить распределение признака в логарифмическом масштабе. Добавьте к графику линии, отображающие среднее и границы интервала метода **трёх сигм**. Напомним, сделать это можно с помощью метода **axvline**. Например, для построение линии среднего будет иметь вид:

```python

histplot.axvline(log_age.mean(), color='k', lw=2)

```

В какую сторону асимметрично логарифмическое распределение? Напишите об этом в комментарии к графику. Найдите выбросы с помощью метода **z**-отклонения и удалите их из данных, используйте логарифмический масштаб. Давайте сделаем "послабление" на 1 сигму (возьмите 4 сигмы) в правую сторону. Выведите таблицу с полученными выбросами и оцените, с каким возрастом соискатели попадают под категорию выбросов?

**Задание 5.6**
  
Сколько выбросов вы нашли с помощью метода **z**-отклонений?

Возможное решение:

```python

fig, ax = plt.subplots(1, 1, figsize=(8, 4))
log_age = np.log(data['Возраст'] + 1)
histplot = sns.histplot(log_age, bins=30, ax=ax)
histplot.axvline(log_age.mean(), color='k', lw=2)
histplot.axvline(log_age.mean()+ 4 *log_age.std(), color='k', ls='--', lw=2)
histplot.axvline(log_age.mean()- 3 *log_age.std(), color='k', ls='--', lw=2)
histplot.set_title('Log Age Distribution');

def outliers_z_score_mod(data, feature, left=3, right=3, log_scale=False):
    if log_scale:
        x = np.log(data[feature]+1)
    else:
        x = data[feature]
    mu = x.mean()
    sigma = x.std()
    lower_bound = mu - left * sigma
    upper_bound = mu + right * sigma
    outliers = data[(x < lower_bound) | (x > upper_bound)]
    cleaned = data[(x >= lower_bound) & (x <= upper_bound)]
    return outliers, cleaned
outliers, cleaned_data = outliers_z_score_mod(data, 'Возраст', left=3,  right=4, log_scale=True)
print(outliers.shape[0])

```

**Ответ**:  

- [x] 3

✍ Отличная работа, коллега! Впереди нас ждёт заключительный, самый ответственный этап: отправим наш проект на проверку ментору.

**[к оглавлению](#оглавление)**

## **<center> Итоги и финальное задание </center>**

✍ Поздравляем! Вы успешно завершили свой первый **data science** проект, и это настоящий повод для гордости! Вы испытали на себе основные этапы работы с данными на примере датасета о резюме и теперь не понаслышке знаете, как важно уметь правильно работать с данными.

Для завершения проекта вам осталось выложить ноутбук на **[GitHub](https://github.com/)** и отправить ссылку на решение ментору, чтобы он проверил ваши выводы по разведывательному анализу, а также указал на недочёты или просто похвалил вас за прекрасную работу :)

**За итоговый проект вы сможете получить 10 баллов**.

**<details>**
<summary> <span style="color:green">Напомнить требования к оформлению ноутбука-решения</span> </summary>

- Решение оформляется только в **Jupyter Notebook**.

- Решение оформляется в соответствии с ноутбуком-шаблоном.

- Каждое задание выполняется в отдельной ячейке, выделенной под задание (в шаблоне они помечены как **ваш код здесь**).

- Код для каждого задания оформляется в одной-двух **jupyter**-ячейках (не стоит создавать множество ячеек для решения задачи, это усложняет проверку).

- Решение должно использовать только пройденный материал: переменные, основные структуры данных (списки, словари, множества), циклы, функции, библиотеки **numpy**, **pandas**, **matplotlib**, **seaborn**, **plotly**. Если вы думаете, что для решения необходимо воспользоваться сторонними библиотеками или инструментами (например **Excel**), другими языками программирования или неизученными конструкциями, вы ошибаетесь :) Все задания решаются с помощью уже знакомых методов.
  
- Код должен быть читаемым и понятным: имена переменных и функций отражают их сущность, важно избегать многострочных конструкций и условий.

- Пользуйтесь **[руководством PEP 8](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/jump_to_id/958c1e42860d475999e9f9381dfe8b5a)**.

- Графики оформляются в соответствии с теми правилами, которые мы приводили в **[модуле по визуализации данных](https://lms.skillfactory.ru/courses/course-v1:SkillFactory+DSPR-2.0+14JULY2021/jump_to_id/1fa00a018157484a9bae5d4557ef3e7c)**.
  
- **Обязательное требование**: графики должны содержать название, отражающее их суть, и подписи осей.
  
- Выводы к графикам оформляются в формате **Markdown** под самим графиком в отдельной ячейке (в шаблоне они помечены как **ваши выводы здесь**). Выводы должны быть представлены в виде небольших связанных предложений на русском языке.

</details>

**ВАЖНЫЕ ЗАМЕЧАНИЯ**:

1. GitHub не позволяет выложить в репозиторий датасет, размер которого превышает 25 Мб. Наш файл с данными весит более 450 Мб. Поэтому добавьте название файла с данными в файл .gitignore, чтобы сделать push своего проекта на GitHub. Выложите файл с данными на другие сервисы для хранения, например:

   - **[Google Диск](https://www.google.ru/drive/)**
   - **[Firebase](https://firebase.google.com/?hl=ru)**  

   В файле для описания вашего проекта **`Readme.md`** или в самом ноутбуке прикрепите ссылку на данные.

2. **GitHub** не поддерживает отображение интерактивной визуализации в **Plotly**. Графики, построенные с помощью **Plotly**, могут не отображаться на странице репозитория.

   **Базовое решение проблемы**: создайте в вашем проекте папку, в которую сохраняйте построенные вами графики в формате **`HTML`** (мы разбирали данный метод в модуле по визуализации данных). Так вы сможете просматривать графики через **GitHub**, открывая файлы в браузере.

**[к оглавлению](#оглавление)**
